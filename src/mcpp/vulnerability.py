from collections import Counter

from mcpp.parse import Sitter
from mcpp.queries import Q_ARGLIST, Q_IDENTIFIER, Q_FUNCTION_PARAMETER, \
    Q_POINTER_EXPR, Q_IDENTIFIER, Q_ASSIGNMENT_EXPR, Q_BINARY_EXPR, Q_CALL_NAME, \
    Q_IF_STMT, Q_SWITCH_STMT, Q_DO_STMT, Q_WHILE_STMT, Q_FOR_STMT, Q_CONDITION, \
    Q_IF_WITHOUT_ELSE


def v1(path, sitter: Sitter):
    """
    V1: number of variables as parameters for callee functions
    """
    queries = {
        "Q_ARGLIST": Q_ARGLIST,
        "Q_IDENTIFIER": Q_IDENTIFIER
    }

    sitter.add_queries(queries)
    tree, lang = sitter.parse_file(path)
    root = tree.root_node

    vars_in_calls = []
    arg_lists = [m for m, tag in sitter.captures("Q_ARGLIST", root, lang) if tag == "args"]
    for arg_list in arg_lists:
        vars_in_calls.extend([m for m, _ in sitter.captures("Q_IDENTIFIER", arg_list, lang)])

    return {
        "V1": len(vars_in_calls)
    }


def v2(path, sitter: Sitter):
    """
    V2: number of variables as parameters for callee functions
    """
    queries = {
        "Q_FUNCTION_PARAMETER": Q_FUNCTION_PARAMETER
    }

    sitter.add_queries(queries)
    tree, lang = sitter.parse_file(path)
    root = tree.root_node

    params = sitter.captures("Q_FUNCTION_PARAMETER", root, lang)
    return {
        "V2": len(params)
    }


def v3_v4(path, sitter: Sitter):
    """
    V3: number of pointer arithmetic operations
    V4: number of variables involved in pointer arithmetics
    """
    queries = {
        "Q_POINTER_EXPR": Q_POINTER_EXPR,
        "Q_IDENTIFIER": Q_IDENTIFIER
    }

    sitter.add_queries(queries)
    tree, lang = sitter.parse_file(path)
    root = tree.root_node
    arith_ops = [
        "+", "++", "+=",
        "-", "--", "-=",
        "*=",  # * excluded (same as pointer reference)
        "/", "/=",
        "^", "^=",
        "&=",  # & excluded (same as pointer dereference)
        "|", "|="
    ]

    pointer_arith = []
    pointer_arith_vars = []
    for pointer, _ in sitter.captures("Q_POINTER_EXPR", root, lang):
        if any(arith in pointer.parent.text.decode() for arith in arith_ops):
            pointer_arith.append(pointer)
            arith_vars = [m for m,_ in sitter.captures("Q_IDENTIFIER", pointer.parent, lang)]
            pointer_arith_vars.extend(arith_vars)

    return {
        "V3": len(pointer_arith),
        "V4": len(pointer_arith_vars)
    }


def v5(path, sitter: Sitter):
    """
    V5: maximum number of pointer arithmetic operations a variable is involved in
    """
    queries = {
        "Q_BINARY_EXPR": Q_BINARY_EXPR,
        "Q_ASSIGNMENT_EXPR": Q_ASSIGNMENT_EXPR,
        "Q_IDENTIFIER": Q_IDENTIFIER,
        "Q_CALL_NAME": Q_CALL_NAME
    }

    sitter.add_queries(queries)
    tree, lang = sitter.parse_file(path)
    root = tree.root_node
    arith_ops = [
        "+", "++", "+=",
        "-", "--", "-=",
        "*", "*=",
        "/", "/="
    ]
    
    # first, we need the function call names to filter them out later
    func_names = set()
    for node, tag in sitter.captures("Q_CALL_NAME", root, lang):
        if tag == "name":
            func_names.add(node.text.decode())

    var_count = Counter()
    candidates = sitter.captures("Q_BINARY_EXPR", root, lang) + sitter.captures("Q_ASSIGNMENT_EXPR", root, lang)
    for node, _ in candidates:
        if len(node.children) != 3:
            continue
        op_text = node.children[1].text.decode()
        if any(arith in op_text for arith in arith_ops):
            variables = [m.text.decode() for m, _ in sitter.captures("Q_IDENTIFIER", node, lang)]
            variables = [v for v in variables if v not in func_names]
            var_count.update(variables)
    if len(var_count) > 0:
        max_count = var_count.most_common(1)[0][1]
    else:
        max_count = 0
    return {
        "V5": max_count
    }


def v6_v7(path, sitter: Sitter):
    """
    V6: number of nested control structures
    V7: maximum level of control nesting
    """
    queries = {
        "Q_IF_STMT": Q_IF_STMT,
        "Q_SWITCH_STMT": Q_SWITCH_STMT,
        "Q_DO_STMT": Q_DO_STMT,
        "Q_WHILE_STMT": Q_WHILE_STMT,
        "Q_FOR_STMT": Q_FOR_STMT
    }

    sitter.add_queries(queries)
    tree, lang = sitter.parse_file(path)
    root = tree.root_node

    nested_controls = []
    max_nesting_level = 0
    for q in queries.keys():
        for node, _ in sitter.captures(q, root, lang):
            nesting_level = _control_nesting_level(node)
            if nesting_level > 0:
                nested_controls.append(node)
                max_nesting_level = max(max_nesting_level, nesting_level)

    return {
        "V6": len(nested_controls),
        "V7": max_nesting_level
    }


def _control_nesting_level(node):
    control_types = [
        "if_statement",
        "switch_statement",
        "do_statement",
        "while_statement",
        "for_statement"
    ]
    parent = node.parent
    num_control_ancestors = 0
    while parent is not None:
        if parent.type in control_types:
            num_control_ancestors += 1
        parent = parent.parent
    return num_control_ancestors


def v8(path, sitter: Sitter):
    """
    V8: maximum number of control-dependent control structures
    """
    queries = {
        "Q_IF_STMT": Q_IF_STMT,
        "Q_SWITCH_STMT": Q_SWITCH_STMT,
        "Q_DO_STMT": Q_DO_STMT,
        "Q_WHILE_STMT": Q_WHILE_STMT,
        "Q_FOR_STMT": Q_FOR_STMT,
        "Q_IDENTIFIER": Q_IDENTIFIER,
        "Q_CONDITION": Q_CONDITION
    }

    sitter.add_queries(queries)
    tree, lang = sitter.parse_file(path)
    root = tree.root_node

    # count dependent controls under another control: key = start_byte of parent in function
    control_dependent_controls = Counter()
    # key: (start_byte of control structure, variable name)
    data_dependent_controls = Counter()
    for q in queries.keys():
        for node, _ in sitter.captures(q, root, lang):
            nesting_level = _control_nesting_level(node)
            if nesting_level > 0:
                parents = _traverse_parent_controls(node)
                if len(parents) > 0:
                    control_dependent_controls[parents[-1].start_byte] += 1
                    for parent in parents:
                        # extract variable names from condition in each parent
                        for condition, tag in sitter.captures("Q_CONDITION", parent, lang):
                            if tag == "condition":
                                for identifier, _ in sitter.captures("Q_IDENTIFIER", condition, lang):
                                    data_dependent_controls[(parent.start_byte, identifier.text.decode())] += 1

    return {
        "V8": max([0] + list(control_dependent_controls.values()))
    }


def _traverse_parent_controls(node):
    """ Climb up the AST and emit all control nodes. """
    control_types = [
        "if_statement",
        "switch_statement",
        "do_statement",
        "while_statement",
        "for_statement"
    ]
    parent_controls = []
    parent = node.parent
    while parent is not None:
        if parent.type in control_types:
            parent_controls.append(parent)
        parent = parent.parent
    return parent_controls


def v9(path, sitter: Sitter):
    """
    V9: maximum number of data-dependent control structures
    """
    queries = {
        "Q_CONDITION": Q_CONDITION,
        "Q_BINARY_EXPR": Q_BINARY_EXPR,
        "Q_IDENTIFIER": Q_IDENTIFIER
    }
    logical_ops = [
        "&", "&&",
        "|", "||"
    ]

    sitter.add_queries(queries)
    tree, lang = sitter.parse_file(path)
    root = tree.root_node

    conditions = sitter.captures("Q_CONDITION", root, lang)
    var_count = Counter()
    for condition in conditions:
        bin_expr = sitter.captures("Q_BINARY_EXPR", root, lang)
        for expr, _ in bin_expr:
            if len(expr.children) != 3:
                continue
            left, op, right = expr.children
            if op.text.decode() in logical_ops:
                for identifier, _ in sitter.captures("Q_IDENTIFIER", expr, lang):
                    var_count[identifier.text.decode()] += 1

    return {
        "V9": max([0] + list(var_count.values()))
    }


def v10(path, sitter: Sitter):
    """
    V10: number of if statements without else
    """
    queries = {
        "Q_IF_WITHOUT_ELSE": Q_IF_WITHOUT_ELSE
    }

    sitter.add_queries(queries)
    tree, lang = sitter.parse_file(path)
    root = tree.root_node

    if_without_else = sitter.captures("Q_IF_WITHOUT_ELSE", root, lang)
    return {
        "V10": len(if_without_else)
    }


def v11(path, sitter: Sitter):
    """
    V11: number of variables in control structures (in each predicate)
    """
    queries = {
        "Q_CONDITION": Q_CONDITION,
        "Q_IDENTIFIER": Q_IDENTIFIER
    }

    sitter.add_queries(queries)
    tree, lang = sitter.parse_file(path)
    root = tree.root_node

    num_controlled_vars = 0
    conditions = sitter.captures("Q_CONDITION", root, lang)
    for condition, _ in conditions:
        num_controlled_vars += len(sitter.captures("Q_IDENTIFIER", condition, lang))
    return {
        "V11": num_controlled_vars
    }
